# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Епифанов Е.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В императивных языках программирования программист четко прописывает последовательность команд, которые должны быть выполнены. В языке Prolog, являющимся примером логического языка, мы описываем пространство состояний, в которых язык сам ищет решение к задаче на основе ранее описанных фактов и правил. Списки в прологе похожи на бинарные деревья.

## Задание 1.1: Предикат обработки списка

Ниже приведены базовые предикаты, которые в дальнейшем будут использоваться при написании более сложных предикатов.

Нахождение длины списка:
```prolog
length_arr([],0). 
length_arr([_|Y],N) :- length_arr(Y,N1), N is N1+1.
```
Пример: 
```prolog
?- length_arr([1,2,3,4],X).
X = 4.
```
Проверка принадлежности элемента списку:
```prolog
member(A,[A|_]).
member(A,[_|Z]) :- member(A,Z).
```
Пример:
```prolog
?- member(a,[a,b,c,d]).
true .
```
Конкатенация списков:
```prolog
append([],X,X).
append([A|X],Y,[A|Z]) :- append(X,[Y],Z).
```
Пример:
```prolog
?- append([a,b,c],d,X).
X = [a, b, c, d].
```
Удаление элемента из списка:
```prolog
remove(X,[X|T],T).
remove(X,[Y|T],[Y|T1]) :- remove(X,T,T1).
```
Пример:
```prolog
?- remove(a,[a,b,c,d],X).
X = [b, c, d] .
```
Перестановка элементов списка:
```prolog
permute([],[]).
permute(L,[X|T]) :- remove(X,L,R), permute(R,T).
```
Пример:
```prolog
?- permute([1,2],X).
X = [1, 2] ;
X = [2, 1] ;
false.
```
Проверка на вхождение подсписка в список:
```prolog
sublist(S,L) :- append(_,L1,L), append(S,_,L1).
```
Пример:
```prolog
?- sublist([2,3],[1,2,3,4]).
true .
```
Далее идет описание реализованных для пункта 4 предикатов.

`append_to_end(X,[],[X]).` - данный предикат добавляет один элемент X в конец списка [X].

Примеры использования:
```prolog
?- append_to_end(f,[a,b,c,d],X).
X = [a, b, c, d, f] .
?- append_to_end(a,X,[b,c,d,a]).
X = [b, c, d] .
?- append_to_end(X,[b,c,d],[b,c,d,a]).
X = a.
```

Реализация:
```prolog
append_to_end(X,[],[X]).
append_to_end(X,[Y|T],[Y|T1]) :- 
    append_to_end(X,T,T1).
```

Выполнение программы стартует с вызова append_to_end(X,[Y|T],[Y|T1]), где X - элемент, который мы добавляем в список, [Y|T] и [Y|T1] - списки, которые рекурсивно лишаются head - Y и отдают tail - T/T1 на дальнейшую обработку. При достижении граничного значения во второй список добавляется введенный ранее элемент, после этого ранее удаленные элементы рекурсивно возвращаются в списки. Таким образом второй список к моменту завершения работы программы восстановит все свои изначальные элементы и будет иметь новый элемент на конце - произошло добавление элемента в конец списка. 

`append_to_end2([Y|T1],X,[Y|T]).` - данный предикат добавляет один элемент X в конец списка [Y|T].

Примеры использования:
```prolog
?- append_to_end2([a,b,c,d],f,X).
X = [a, b, c, d, f].
?- append_to_end2(X,f,[a,b,c,d,f]).
X = [a, b, c, d] .
?- append_to_end2([a,b,c,d],X,[a,b,c,d,f]).
X = f.
```

Реализация:
```prolog
append_to_end2([Y|T1],X,[Y|T]) :- append(T1,[X],T).  
```

Выполнение программы стартует с вызова append_to_end2([Y|T1],X,[Y|T]), где X - элемент, который мы добавляем в список, [Y|T] и [Y|T1] - списки, которые рекурсивно лишаются head - Y и отдают tail - T/T1 на дальнейшую обработку. При достижении граничного значения во второй список добавляется введенный ранее элемент, после этого ранее удаленные элементы рекурсивно возвращаются в списки. Таким образом второй список к моменту завершения работы программы восстановит все свои изначальные элементы и будет иметь новый элемент на конце - произошло добавление элемента в конец списка. 

## Задание 1.2: Предикат обработки числового списка

`prov([X|[Y|L]])` - данный предикат проверяет список на арифметическую прогрессию.

Примеры использования:
```prolog
?- prov([1,2,3,4,5]).
true .
?- prov([1,-2,3,-4,5,8]).
false.
?- prov([-3,3,9,15,21]).
true .
```

Реализация:
```prolog
prov([_]) :- ar_prg(_,_,[]).
prov([X|[Y|L]]) :- D is Y-X, ar_prg(D,Y,L).     
 
ar_prg(D,Y,[T|L]) :- D =:= T-Y, ar_prg(D,T,L).
ar_prg(_,_,[]).
```

Выполнение программы начинается с вызова prov([X|[Y|Z]]). Пользователь указывает список как параметр, и он сразу же разделяется на 2 головных элемента и хвост, далее вычисляется шаг D как разница между первым и вторым элементом списка. Потом вычисления происходят в предикате ar_prg(D,Y,[T|L]), где D - шаг, Y - первый элемент списка из прошлой итерации, он нужен для дальнейшей проверки шага между элементами в списке. [T|L] - исходный список, от которого также заранее отделяется голова для сравнения шага с разницей между головой и Y. Сравнения продолжаются до тех пор, пока исходный список не опустеет или пока не нарушится условие сравнения. Дополнительно в начале описан предикат для проверки списка с одним элементом на арифметическую прогрессию.

`prov2([X|[Y|L]])` - данный предикат проверяет список на арифметическую прогрессию.

Примеры использования:
```prolog
?- prov2([1,2,3,4,5]).
true .
?- prov2([1,-2,3,-4,5,8]).
false.
?- prov2([0,3,6,9,13,15]).
false.
```

Реализация:
```prolog
prov2([_]).                                       
prov2([X|[Y|L]]) :- D is Y-X, dop_prov2([Y|L],D,X).
 
dop_prov2([],_,_).
dop_prov2(L,D,Z) :- H is Z+D, remove(H,L,P), dop_prov2(P,D,H).
```

Выполнение программы начинается с вызова prov2([X|[Y|Z]]). Пользователь указывает список как параметр, и он сразу же разделяется на 2 головных элемента и хвост, далее вычисляется шаг D как разница между вторым и первым элементом списка. После вычисления начинаются в предикате dop_prov2, куда передается исходный список без головы, шаг и первый элемент исходного списка. В этом предикате вычисляется новый предположительный элемент последовательности (такой, что условие арифметической прогрессии с шагом D выполняется), после он удаляется иначе возвращается false, так как элемент не найден - соответственно, для списка не выполняется условие арифметической прогрессии. Если условие арифметической прогрессии выполняется для списка, то рекурсия дойдет до граничного значения предиката dop_prov2([],_,_). После этого программа вернет true, так как список удовлетворяет условию арифметической прогрессии. Аналогично предыдущей программе в этой присутствует предикат для обработки списка из одного элемента.

## Задание 2: Реляционное представление данных

Преимущества реляционной модели в том, что она проста для понимания и использования, она логична - удобна для разработки. Недостатки заключаются в сложности при проектировании сложных баз данных, в ограниченности, которая мешает при хранении большого количества данных, в низкой производительности при работе с большим объемом данных. В моем варианте используется представление данных №4 - предикаты с фамилиями студентов групп и предикаты с оценками для каждого предмета. Удобство данного представления в распределении данных по двум группам - студенты и предметы со всеми оценками. При необходимости можно брать фамилию студента из первой группы и использовать её как параметр при обработке групп с предметами и оценками.

### Первый предикат - Напечатать средний балл для каждого предмета.

`print_average_score(_)`.

Реализация:
```prolog
help_func(0,0,[]).
help_func(S,Q,[grade(_,O)|Z]) :- help_func(S1,Q1,Z), S is S1+O, Q is Q1+1.

average_score(X,A) :- subject(X,Z), help_func(S,Q,Z), A is S/Q, write(X), write(" - "), write(A), nl. 

print_average_score(_) :- findall(X,average_score(X,A),_).
```

Примеры использования:
```prolog
?- print_average_score(_).
Логическое программирование - 4.107142857142857
Математический анализ - 4.035714285714286
Функциональное программирование - 4.107142857142857
Информатика - 3.8214285714285716
Английский язык - 4
Психология - 3.857142857142857
true.
```
`print_average_score(_)` - выполняет предикат average_score(X,A) для всех возможных значений X.

`average_score(X,A)` - получает список оценок для предмета, вызывает help_func(S,Q,Z) для списка оценок, считает и выводит среднюю оценку по предмету.

`help_func(S,Q,Z)` - рекурсивно считает сумму и количество оценок по предмету.

### Второй предикат - Для каждой группы найти количество не сдавших студентов.

`print_bad_grade(_)`.

Реализация:
```prolog
get_grades(S, G) :- findall(Grade, (subject(_, GradesList), member(grade(S, Grade), GradesList)), G).

help_func2([],0).
help_func2([S|C1],K) :- help_func2(C1,K1), get_grades(S, G), 
    (member(2,G) -> K is K1+1 ; K is K1).

bad_grade(X,A) :- group(X,C), help_func2(C,K), A is K, write(X), write(" - "), write(A), write(" чел."), nl.

print_bad_grade(_) :- findall(X,bad_grade(X,A),_).
```

Примеры использования:
```prolog
?- print_bad_grade(_).
102 - 3 чел.
101 - 3 чел.
104 - 2 чел.
103 - 2 чел.
true.
```
`print_bad_grade(_)` - выполняет предикат bad_grade(X,A) для всех возможных значений X.

`bad_grade(X,A)` - получает список студентов из группы, выполняет предикат help_func2(C,K), получает переменную с количеством студентов, подходящих под условие задания и выводит результат работы программы.

`help_func2([S|C1],K)` - вызывает предикат get_grades(S, G) и получает от него список оценок для студента S. Если в списке присутствует оценка 2, студент подходит под условие задания.

`get_grades(S, G)` - выполняет для всех возможных оценок Grade проверку вхождения блока grade студента S в GradeList, полученном при вызове subject от анонимной переменной - предмета. Результат работы (список оценок) записывается в переменную G. 

### Третий предикат - Найти количество не сдавших студентов для каждого из предметов.

`print_bad_students(_)`.
```prolog
help_func3([grade(_,O)|Z],K) :- help_func3(Z,K1), (O == 2 -> K is K1+1 ; K is K1).

bad_students(X,A) :- subject(X,Z), help_func3(Z,K), A is K, write(X), write(" - "), write(A), write(" чел."), nl.

print_bad_students(_) :- findall(X,bad_students(X,A),_).
```
Примеры использования:
```prolog
?- print_bad_students(_).
Логическое программирование - 3 чел.
Математический анализ - 1 чел.
Функциональное программирование - 0 чел.
Информатика - 2 чел.
Английский язык - 2 чел.
Психология - 2 чел.
true.
```
`print_bad_students(_)` - выполняет предикат bad_students(X,A) для всех возможных значений X.

`bad_students(X,A)` - получает список оценок для определенного предмета X, вызывает предикат help_func3([grade(_,O)|Z],K), получает переменную с ответом на задачу и выводит его.

`help_func3([grade(_,O)|Z],K)` - рекурсивно проходит по каждой записи grade и, сравнивая оценку из записи с 2, добавляет к счетчику единицу или нет. 

## Выводы

При выполнении лабораторной работы я усовершенствовал свои навыки использования предикатов в языке Prolog. Я научился обрабатывать обычные и числовые списки с помощью соответствующих предикатов, реализованных самостоятельно или с помощью базовых предикатов. Во время выполнения лабораторной работы я столкнулся с некоторыми проблемами, связанными с логикой работы предикатов при изменении каких-либо передающихся ими параметров. Проблема была решена косметической переработкой кода - код стал более понятным при восприятия и тестирования.
